#ifndef GEN_LIQUIDITY_RESULTS
#define GEN_LIQUIDITY_RESULTS

// AUTOGENERATED header. DO NOT modify manually.
//
#include <string>
#include <vector>
#include <nlohmann/json.hpp>
#include <minter/eth/Common.h>
#include <minter/hash.h>
#include <minter/address.h>
#include <minter/tx/tx_type.h>
#include "wallet/liquidity/base.h"



namespace wallet {
namespace liquidity {

struct bip_price {
	int price;
	std::string next_update;
	float delta;
};
struct sell_result {
	minter::address_t address;
	std::string tag;
};
struct buy_tag_info {
	minter::address_t address;
	dev::bigint btc_price;
	dev::bigint bip_price;
	std::string coin;
	dev::bigint amount;
};
struct buy_btc_address {
	std::string address;
};
struct buy_status {
	std::string coin;
	dev::bigint amount;
};
inline void from_json(const nlohmann::json& j, ::wallet::liquidity::bip_price& resp) {
	if(j.find("price") != j.end() && !j.at("price").is_null()) j.at("price").get_to<int>(resp.price);
	if(j.find("next_update") != j.end() && !j.at("next_update").is_null()) j.at("next_update").get_to<std::string>(resp.next_update);
	if(j.find("delta") != j.end() && !j.at("delta").is_null()) j.at("delta").get_to<float>(resp.delta);
}
inline void to_json(nlohmann::json& j, const ::wallet::liquidity::bip_price& resp) {
	j = nlohmann::json{
		{"price", resp.price},
		{"next_update", resp.next_update},
		{"delta", resp.delta},
	};
}
inline void from_json(const nlohmann::json& j, ::wallet::liquidity::sell_result& resp) {
	if(j.find("address") != j.end() && !j.at("address").is_null()) j.at("address").get_to<minter::address_t>(resp.address);
	if(j.find("tag") != j.end() && !j.at("tag").is_null()) j.at("tag").get_to<std::string>(resp.tag);
}
inline void to_json(nlohmann::json& j, const ::wallet::liquidity::sell_result& resp) {
	j = nlohmann::json{
		{"address", resp.address},
		{"tag", resp.tag},
	};
}
inline void from_json(const nlohmann::json& j, ::wallet::liquidity::buy_tag_info& resp) {
	if(j.find("minter_address") != j.end() && !j.at("minter_address").is_null()) j.at("minter_address").get_to<minter::address_t>(resp.address);
	if(j.find("btc_price") != j.end() && !j.at("btc_price").is_null()) j.at("btc_price").get_to<dev::bigint>(resp.btc_price);
	if(j.find("price") != j.end() && !j.at("price").is_null()) j.at("price").get_to<dev::bigint>(resp.bip_price);
	if(j.find("coin") != j.end() && !j.at("coin").is_null()) j.at("coin").get_to<std::string>(resp.coin);
	if(j.find("amount") != j.end() && !j.at("amount").is_null()) j.at("amount").get_to<dev::bigint>(resp.amount);
}
inline void to_json(nlohmann::json& j, const ::wallet::liquidity::buy_tag_info& resp) {
	j = nlohmann::json{
		{"minter_address", resp.address},
		{"btc_price", resp.btc_price},
		{"price", resp.bip_price},
		{"coin", resp.coin},
		{"amount", resp.amount},
	};
}
inline void from_json(const nlohmann::json& j, ::wallet::liquidity::buy_btc_address& resp) {
	if(j.find("address") != j.end() && !j.at("address").is_null()) j.at("address").get_to<std::string>(resp.address);
}
inline void to_json(nlohmann::json& j, const ::wallet::liquidity::buy_btc_address& resp) {
	j = nlohmann::json{
		{"address", resp.address},
	};
}
inline void from_json(const nlohmann::json& j, ::wallet::liquidity::buy_status& resp) {
	if(j.find("coin") != j.end() && !j.at("coin").is_null()) j.at("coin").get_to<std::string>(resp.coin);
	if(j.find("will_receive") != j.end() && !j.at("will_receive").is_null()) j.at("will_receive").get_to<dev::bigint>(resp.amount);
}
inline void to_json(nlohmann::json& j, const ::wallet::liquidity::buy_status& resp) {
	j = nlohmann::json{
		{"coin", resp.coin},
		{"will_receive", resp.amount},
	};
}


}
}

#endif
