/*!
 * mintex.
 * main.cpp
 *
 * \date 2019
 * \author Eduard Maximovich (edward.vstock@gmail.com)
 * \link   https://github.com/edwardstock
 */

#include <unordered_map>
#include <utility>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
#include <fstream>
#include <toolboxpp.hpp>
#include <nlohmann/json.hpp>
#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>
#include <boost/system/error_code.hpp>
#include <fmt/format.h>


namespace po = boost::program_options;
namespace fs = boost::filesystem;

struct field_item {
  std::string type;
  std::string name;
  std::string serialized_name;
  bool custom_encode_decode = false;
};

struct type_out {
  std::string name;
  std::string parent;
  std::vector<field_item> fields;
  std::vector<std::string> custom_rows;
};

struct file_out {
  std::vector<std::string> includes;
  std::vector<type_out> types;
};

class printer {
public:
    printer(std::ostream &s, const std::string &def_name) :
        s(s),
        def_name(def_name) {
    }
    printer(std::ostream &s, const std::string &def_name, std::vector<std::string> &&namespaces) :
        s(s),
        def_name(def_name),
        ns(std::move(namespaces)) {
    }

    printer &begin(const std::vector<std::string> &includes) {
        s << "#ifndef " << def_name << "\n";
        s << "#define " << def_name << "\n";
        s << R"(
// AUTOGENERATED header. DO NOT modify manually.
//
)";
        for (const auto &in: includes) {
            add_include(in);
        }
        if (ns.size()) {
            s << "\n\n";
            for (const auto &n: ns) {
                s << "\nnamespace " << n << " {";
            }

            s << "\n";
        }

        return *this;
    }

    std::string get_ns() {
        if (!ns.size()) {
            return std::string();
        }

        std::stringstream ss;
        ss << "::";
        int i = 0;
        for (const auto &n: ns) {
            ss << n << "::";
        }

        return ss.str();
    }

    printer &add_include(const std::string &include) {
        if (!include.length()) {
            return *this;
        }

        if (include[0] != '<') {
            s << fmt::format("#include \"{0}\"\n", include);
        } else {
            s << fmt::format("#include {0}\n", include);
        }

        return *this;
    }

    printer &create_struct(const type_out &type) {
        structs.push_back(type);
        return *this;
    }

    printer &end() {
        std::deque<type_out> tmp;
        while(!structs.empty()) {
            type_out type = structs.front();
            structs.pop_front();
            tmp.push_back(type);

            s << "\n";
            s << "struct " << type.name;
            if (type.parent != "") {
                s << " : public " << type.parent << " ";
            }
            s << " {";

            for(const auto& field: type.fields) {
                s << "\n\t" << field.type << " " << field.serialized_name << ";";

                if(field.custom_encode_decode) {
                    type.custom_rows.push_back(fmt::format(
                        R"(static ::nlohmann::json _{0}_encode(nlohmann::json &j, const {1}& resp))", field.name, get_ns() + type.name));
                    type.custom_rows.push_back(fmt::format(
                        R"(static void _{0}_decode(const nlohmann::json &j, {1}& resp))", field.name, get_ns() + type.name));
                }
            }

            for(const auto& custom: type.custom_rows) {
                s << "\n\t" << custom << ";";
            }
            s << "\n};";
        }

        while(!tmp.empty()) {
            type_out type = tmp.front();
            generate_json_bindings(type);
            tmp.pop_front();
        }


        if (ns.size()) {
            s << "\n\n";
            for (const auto &n: ns) {
                s << "\n}";
            }
        }

        s << "\n\n#endif\n";
        return *this;
    }

    printer &generate_json_bindings(const type_out &type) {
        s << "\n" << fmt::format("inline void from_json(const nlohmann::json& j, {0}& resp) {{", get_ns() + type.name);

        for (const auto &field: type.fields) {
            if (!field.custom_encode_decode) {
                s << "\n\t" << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) j.at("{0}").get_to<{1}>(resp.{2});)",
                                           field.name,
                                           field.type,
                                           field.serialized_name);
            } else {
                s << "\n\t";
                s << fmt::format(R"(if(j.find("{0}") != j.end() && !j.at("{0}").is_null()) )", field.name);
                s << fmt::format(R"({0}{1}::_{2}_decode(j, resp);)", get_ns(), type.name, field.serialized_name);
            }

        }
        s << "\n}";

        s << "\n" << fmt::format("inline void to_json(nlohmann::json& j, const {0}& resp) {{", get_ns() + type.name);

        s << "\n\t";
        s << "j = nlohmann::json{";
        for (const auto &field: type.fields) {
            s << "\n\t\t";
            if (!field.custom_encode_decode) {
                s << fmt::format(R"({{"{0}", resp.{1}}},)", field.name, field.serialized_name);
            } else {
                s << fmt::format(R"({{"{0}", {1}{2}::_{3}_encode(j, resp)}},)",
                                 field.name,
                                 get_ns(),
                                 type.name,
                                 field.serialized_name);
            }

        }
        s << "\n\t};";
        s << "\n}";

        return *this;
    }

private:
    std::deque<type_out> structs;
    std::ostream &s;
    std::vector<std::string> ns;
    std::string def_name;
};

struct source_file {
  fs::path path;
  fs::path target_path;
  std::string filename;
};

int main(int argc, char **argv) {

    po::options_description desc("Allowed options");
    desc.add_options()
            ("help", "produce help message")
            ("source,S", po::value<std::string>(), "json descriptors source path")
            ("target,T", po::value<std::string>(), "target generated path")
            ("namespaces,N", po::value<std::vector<std::string>>(), "target namespace");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    if (!vm.count("source") || !vm.count("target")) {
        std::cout << "\t--source and --target required!\n";
        std::cout << desc << "\n";
        return 1;
    }

    if (vm.count("help")) {
        std::cout << desc << "\n";
        return 0;
    }

    auto target_path = vm.at("target").as<std::string>();
    fs::path target_dir(target_path);

    auto search_path = vm.at("source").as<std::string>();
    fs::path search_dir(search_path);

    std::vector<source_file> source_files;
    for (fs::directory_entry &x : fs::directory_iterator(search_dir)) {
        if (x.path().extension() == ".json") {

            std::string filename = toolboxpp::strings::substringReplace(".json", "", x.path().filename().string());
            source_files.emplace_back(source_file{
                x.path().string(),
                fs::path(target_dir.string() + "/wallet/" + filename),
                filename
            });
        }
    }

    for (const auto &source: source_files) {
        nlohmann::json j;
        std::ifstream is(source.path.string(), std::ios::in);
        if (!is.is_open()) {
            std::cerr << "Can't open file " << source.path << "\n";
            return 1;
        }

        if (!fs::is_directory(source.target_path)) {
            bool created = fs::create_directories(source.target_path);
            if (!created) {
                std::cerr << "target \"" << source.target_path << "\" is not a directory" << "\n";
            }

            return 1;
        }
        std::ofstream of(source.target_path.string() + "/results.hpp", std::ios::out);
        is >> j;

        file_out out;

        j.at("includes").get_to(out.includes);
        auto struct_item = j.at("responses");
        for (const auto &item: struct_item) {
            type_out type{};
            item.at("name").get_to<std::string>(type.name);
            if(item.find("parent") != item.end()) {
                item.at("parent").get_to<std::string>(type.parent);
            }
            for (const nlohmann::json &field: item.at("fields")) {

                std::string f_type, f_name, f_serialized_name;
                bool f_custom_encode_decode = false;

                f_type = field[0].get<std::string>();
                f_name = field[1].get<std::string>();

                if (field.size() >= 3 && field[2].get<std::string>() != "") {
                    f_serialized_name = field[2].get<std::string>();
                } else {
                    f_serialized_name = f_name;
                }
                if (field.size() >= 4 && field[3].is_boolean()) {
                    f_custom_encode_decode = field[3].get<bool>();
                }

                type.fields.push_back(field_item{
                    f_type,
                    f_name,
                    f_serialized_name,
                    f_custom_encode_decode
                });
            }

            out.types.push_back(std::move(type));
        }

        printer p(of, toolboxpp::strings::toUpper("GEN_"+source.filename+"_RESULTS"), {
            "wallet",
            source.filename
        });
        p.begin(out.includes);

        for (const auto &type: out.types) {
            p.create_struct(type);
        }

        p.end();

        std::cout << std::endl;

        of.flush();
        of.close();
    }

}
 